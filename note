The extended ASCII character table is of length 256 (has 256 printable characters). Each character has a corresponding character code can be reresented numerically as decimal (base 10), hexadecimal (base 16) and octagonal (base 8) formats. 

For example, the character 3 has a decimal representation of 51. It is the 52nd element of the ASCII table so takes value 51 as the decimal numbering starts from 0. It can also be represented as a hexadecimal and octagonal number. In each case we want to calculate the number 51 (in decimals, base 10) using either base 16 (hexadecimals) or base 8 (octagonals). In base 10 we have 10^0 i.e. 1 as the first digit and 10^1 i.e. 10 as the second digit so the number 51 is composed of 5 copies of 10 and 1 copy of 1 (i.e. 5*10 + 1*1). We can convert the decimal 51 into a hexadecimal according to 3*16 + 3*1 so the decimal 51 in hexadecimals is 33. Similarly, in octogonals the decimal 51 is given by 63 (63 = 6*8 + 3*1).

Characters represented by the decimals 0-31 are non-printable control characters. Characters represented by the decimals 32-127 are printable characters containing letters, digits and symbols. This is the character set I am interested in.

The sha256 hash algorithm in hashlib returns a bytes object, bytes_obj. This is an immutable sequence of integers in the range 0<= x <256. Each integer in this sequence is a decimal representation of an ASCII character. So bytes_obj[i] returns an integer which is in the range 0-255 for every item, i, in the sequence of integers that make up the bytes object, bytes_obj. Note, bytes_obj[0:1] does not return the integers of the first and second byte, see built in types: bytes documentation (https://docs.python.org/3/library/stdtypes.html#bytes).

=====
Acceptable ASCII characters for a password (not including quotes etc)
Decimals 48 - 122 
difference between decimals is 75 (include both end points)

integer mod 75 means that new integers will range from 0 to 74


min new integer is 0 and max new integer is 74. Add on adjustment (min acceptable decimal = 48). then the adjusted integers will be in the range 48 - 122 as required.

0 + 48 = 48
74 + 48 = 122


6 - 10, diff=4
6 mod 4 = 2
7 mod 4 = 3
8 mod 4 = 0
9 mod 4 = 1
10 mod 4 = 2
=====
Method:

- Use hashlib to use a hashing algorithm and return a bytes object.
- convert bytes object into the list of integers
- create an empty list to populate with characters
- loop over bytes object
    - convert each item in sequence into an integer between 0 and 255
    - modulo each integer with the difference between the first and last acceptable decimals (max - min + 1 to include the end points)
    - adjust this value by adding on the minimum acceptable decimal value
    - this value should be an integer between the minimum and maximum acceptable decimals
    - append character represented by the adjusted decimal into the character list

- use the first 12 characters as the new password

*** need to think about the case where an illegal symbol occurs and the case where a symbol does not occur ***
=====
list(bytes_obj): You can convert a bytes object, bytes_obj into a list of integers using list(bytes_obj). Note: the bytes object is a sequence of integers where each integer is in 0-255

See: https://docs.python.org/3/library/stdtypes.html#bytes.


chr(i): This is an in-built python function that returns the string representing the character whose Unicode code point is the integer i. For example, chr(51) returns the string '3'. Decimals 0-255 represent the same character when using Unicode and ASCII.  
